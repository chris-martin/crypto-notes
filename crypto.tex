\documentclass[11pt]{article}
\date{}
\title{Notes from CS 6260 (Applied Cryptography)\\Georgia Tech, Fall 2012}
\author{Christopher Martin\\{\tt chris.martin@gatech.edu}}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsmath,amsfonts,amssymb,amsthm}

% bold math in headers
\makeatletter
\DeclareRobustCommand*{\bfseries}{%
  \not@math@alphabet\bfseries\mathbf
  \fontseries\bfdefault\selectfont
  \boldmath
}
\makeatother

\renewcommand{\labelitemi}{}

\newcommand{\eqdef}{\ensuremath{\equiv}}

\newcommand{\Gen}{\ensuremath{\mathsf{Gen}}}
\newcommand{\Enc}{\ensuremath{\mathsf{Enc}}}
\newcommand{\AEnc}{\ensuremath{\mathsf{AEnc}}}
\newcommand{\EEnc}{\ensuremath{\mathsf{EEnc}}}
\newcommand{\Dec}{\ensuremath{\mathsf{Dec}}}
\newcommand{\Tag}{\ensuremath{\mathsf{Tag}}}
\newcommand{\Ver}{\ensuremath{\mathsf{Ver}}}

\newcommand{\eps}{\ensuremath{\varepsilon}}

\newcommand{\bit}{\ensuremath{\{\texttt{0},\texttt{1}\}}}

\newcommand{\ang}[1]{\ensuremath{\langle#1\rangle}}

\theoremstyle{remark}
\newtheorem{thm}{Theorem}

\begin{document}

\maketitle

\section{Symmetric cryptography scheme}

\begin{tabular}{r|l}
Key space & $\mathcal{K}$ \\
Message space & $\mathcal{M}$ \\
Cypher space & $\mathcal{C}$ \\
Key generator & $\Gen : \phi \rightarrow \mathcal{K}$ \\
Encryption function &
$\Enc : \{\mathcal{K} \times \mathcal{M}\} \rightarrow \mathcal{C}$ \\
Decryption function &
$\Dec : \{\mathcal{K} \times \mathcal{C}\} \rightarrow \mathcal{M}$
\end{tabular}

\section{Information theoretic security}

Information theoretic security repels even resource-unbounded attackers.
Shannon secrecy and perfect secrecy are equivalent definitions of
information theoretic security for symmetric cryptography schemes.

\paragraph{Shannon secrecy}
A scheme is Shannon-secret with respect to the distribution $D$ over $\mathcal{M}$
iff the ciphertext reveals no additional information about the message.
\[ \forall \, M \in \mathcal{M}, \, C \in \mathcal{C}: \;
  \Pr_{\substack{k \leftarrow \Gen\\m \in D}} \big[\, m = M \,\vert\, \Enc_k(m) = C \,\big]
= \Pr_{m\in D} \big[\, m = M \,\big] \]

\paragraph{Perfect secrecy}
A scheme is perfectly secret iff the distributions of ciphertexts for any
two messages are identical.
\[\forall\, M_1, M_2 \in \mathcal{M},\, C \in \mathcal{C}:\;
  \Pr_{K_1\leftarrow\Gen} \big[\, \Enc_{K_1}(M_1) = C \,\big]
= \Pr_{K_2\leftarrow\Gen} \big[\, \Enc_{K_2}(M_2) = C \,\big] \]

This model considers only a single message and ciphertext,
so although a one-time pad is perfectly secret, a ``two-time pad'' is not.

\begin{thm}
Perfect secrecy $\Rightarrow$ $|\mathcal{K}| \ge |\mathcal{M}|$.
\begin{proof}
If not, $\exists$ $2$ messages with different probabilities
of encrypting to the same cypertext.
\end{proof}
\end{thm}

\section{Pseudo-random functions}

\paragraph{Uniformly random function}
$U$ is a random variable chosen uniformly from the set of all functions
$\{0,1\}^m \rightarrow \{0,1\}^n$.

\paragraph{Pseudo-random function}
A PRF belongs to a family of functions
$F : \{0,1\}^\ell \times \{0,1\}^m \rightarrow \{0,1\}^n$.
Write $F_k(\cdot)$ to denote $F(k, \cdot)$.

\paragraph{Distinguishing advantage}
Consider an adversary $\mathcal{A}$ who knows $F$, having oracle access
to $F_k$ where $k$ was chosen uniformly at random, trying to
distinguish the oracle's responses from a random function.
The distinguishing advantange of $\mathcal{A}$ against $F$ is
\[ \textrm{Adv}_F^\textrm{prf}(\mathcal{A}) \eqdef
\Pr_{k\in\{0,1\}^\ell} \big[\, \mathcal{A}^{F_k}\;\textrm{accepts} \,\big]
- \Pr_U \big[\, \mathcal{A}^U \textrm{ accepts} \,\big] \;\textrm{.} \]

In time $O(t)$, we can brute-force $t$ keys to get
advantage $t / 2^\ell$.

\paragraph{$(t,q)$-bounded adversary}
\begin{tabular}{r|l}
$t$ & Running time \\
$q$ & Number of queries
\end{tabular}

\paragraph{$(t,q,\eps)$-secure PRF}
$F$ is $(t,q,\eps)$-secure iff
$\forall$ $(t,q)$-bounded $\mathcal{A}$,
\[ \textrm{Adv}_F^\textrm{prf}(\mathcal{A}) \le \eps \;\textrm{.} \]

\paragraph{Examples of reasonable constants}
\begin{tabular}{r|l}
$t$ & $2^{128}$ \\
$q$ & $2^{64}$ or $2^{32}$ \\
$\eps$ & $2^{-128}$
\end{tabular}

\paragraph{Existence}
The existence of secure PRFs has not been proven,
but there are some functions that have never been
broken and are widely assumed to be PRFs.

\section{Reduction}

\paragraph{Karp (many-to-one) reduction}
Reduction from $A$ to $B$ transforms
an instance of $A$ to an instance of $B$.

\paragraph{Cook (Turing) reduction}
Reduction from $A$ to $B$ solves $A$
using a subroutine that solves $B$.

\paragraph{Key recovery security}
$F$ is $(t,q,\eps)$-kr-secure
iff $\forall$ $(t,q)$-bounded $\mathcal{A}$,
\[ \textrm{Adv}_F^\textrm{kr} \eqdef
\Pr_{k \in \{0,1\}^\ell} \big[\,
  \mathcal{A}^{F_k(\cdot)}\;\textrm{outputs}\;k
\,\big] \le \eps \;\textrm{.} \]

\begin{thm}
If $F$ is a $(t,q,\eps)$-secure PRF
for $q < 2^m$, then
$F$ is $(t',q',\eps')$-kr-secure for
$t' \approx t$, $q' = q-1$, $\eps' = \epsilon + 2^{-n}$.
\begin{proof}
Cook reduction.
For any kr-adversary $\mathcal{A'}$ running in
time $t'$ and making $q'<2^m$ queries, let $\mathcal{A}$ be
the PRF adversary:
\begin{quote}
$k' \; \leftarrow \; \mathcal{A}'(\mathcal{O})$ \\
$x \; \leftarrow$ a value that $\mathcal{A}'$ did not query with \\
$y \; \leftarrow \; \mathcal{O}(x)$ \\
Accept iff $y = F_{k'}(x)$
\end{quote}
$\mathcal{A}$ runs in time $t \approx t'$ and makes $q = q'+1$ queries.
\[ \textrm{Adv}_F^\textrm{prf}(\mathcal{A}) \ge
\textrm{Adv}_F^\textrm{kr}(\mathcal{A}') - 2^{-n}
\;\textrm{.} \qedhere \]
\end{proof}
\end{thm}

\paragraph{Example PRF construction}
For PRF $F : \bit^\ell \times \bit^n \rightarrow \bit^n$,
$F'_k(x) \eqdef F_k(F_k(x)) \Vert F_k(\overline{F_k(x)})$

\begin{thm}
$F'$ is $\displaystyle (t, \frac{q}{3}, \eps + \frac{q^2}{2^n})$-secure.
\begin{proof}
Let $\mathcal{A}'$ be an attacker on $F'$.
Define $\mathcal{A}$ as:
\begin{quote}
$\mathcal{O}' \eqdef
\mathcal{O}(\mathcal{O}(x)) \Vert \mathcal{O}(\overline{\mathcal{O}(x)})$
(done with $3$ queries to $\mathcal{O}$)

Accept iff $\mathcal{A}'^{\,\mathcal{O}'}$ accepts
\end{quote}
$\mathcal{O}'(x)$ simulates $F'$ perfectly, so
$\displaystyle
\Pr_k \big[\, \mathcal{A}^{F_k} \,\big] =
\Pr_k \big[\, \mathcal{A'}^{\,F'_k} \,\big]$.

$\mathcal{O}'$ does not simulate $U$ perfectly, but it is close.
We have independence as long as all of the
$\mathcal{O}(x)$, $\overline{\mathcal{O}(x)}$ are distinct.
Using union bound, this probability $\le \frac{q^2}{2^n}$
\end{proof}
\end{thm}

\section{Pseudo-random permutations}

In a permutation family
$F : \{0,1\}^\ell \times \{0,1\}^n \rightarrow \{0,1\}^n$,
every $F_k$ is bijective.

A secure PRP is computationally indistinguishable from
a uniformly random permutation.

\paragraph{Some well-known PRPs}
\begin{tabular}{l|lll}
$\mathsf{DES}$ & $\ell = 56$ & $n = 64$ \\
$\mathsf{AES_{128}}$ & $\ell = 128$ & $n = 128$ \\
$\mathsf{AES_{192}}$ & $\ell = 192$ & $n = 128$
\end{tabular}

\paragraph{Strong PRP / block cipher}
Attackers with oracle access to both $F$ and $F^{-1}$
have small advantage. \[
\text{Adv}_F^\text{sprp} \eqdef
  \Pr_k \big[\, \mathcal{A}^{F_k,F_k^{-1}} \; \text{accepts} \,\big]
- \Pr_P \big[\, \mathcal{A}^{P,P^{-1}} \; \text{accepts} \,\big]
\le \eps
\]

\paragraph{PRF/PRP switching lemma}
If $G$ is a $(t, q, \eps)$-secure PRP (not necessarily strong),
then $F$ is a $(t, q, \eps + \frac{q^2}{2^{n+1}})$-secure PRF.

\section{Secure symmetric encryption}

Perfect secrecy is impossible where $m > \ell$, but
computational security is possible with pseudorandom objects.

\paragraph{Electronic code block (ECB)}
Suppose $F$ is a secure PRP
$\bit^\ell\times\bit^n\rightarrow\bit^n$
with $F$ and $F^{-1}$ efficiently computable.
~\\[5pt]
\begin{tabular}{r|l}
\Gen & $k \leftarrow \bit^\ell$ \\[5pt]
\Enc & $M'$ $\leftarrow$ Pad message $M$
       with \texttt{1} and some \texttt{0}s
       to a multiple of $n$. \\
     & Break $M'$ into $n$-bit blocks $m_0, m_1, \ldots$ \\
     & Apply $F_k$ to each of the $\{m\}$ \\[5pt]
\Dec & Apply $F'_k$ to each of the $\{m\}$
\end{tabular}\\\\
Repeated blocks give repeated ciphertext.
Never use ECB.

\paragraph{Security model}
Adversary, seeing all cipthertexts and
having oracle access to $\Enc_k$,
learns nothing about plaintexts
(except message length, which is unavoidable).

$SE = (\Gen, \Enc, \Dec)$ is
$(t, \sigma, \eps)$-IND-CPA secure
(``indistinguishable under chosen-plaintext attack'')
iff $\forall$ $(t, \sigma)$-bounded $\mathcal{A}$, \[
\text{Adv}_{SE}^\text{indcpa}(\mathcal{A}) \eqdef
\Pr_{k \leftarrow \Gen} \big[\, \mathcal{A}^{L_k} \; \text{accepts} \,\big]
- \Pr_{k \leftarrow \Gen} \big[\, \mathcal{A}^{R_k} \; \text{accepts} \,\big]
\;\text{,}
\]
\[ L_k(m, m') \eqdef \Enc_k(m)
\;\text{if}\; |m| = |m'|\;\text{else}\; \bot \;\text{,} \]
\[ R_k(m, m') \eqdef \Enc_k(m')
\;\text{if}\; |m| = |m'|\;\text{else}\; \bot \;\text{,} \]
$t$ is the running time, and
$\sigma$ total length of all message queries.

Equivalent definition:
$\Enc_k$ is computationally indistinguishable from
a zero-encrypting oracle $Z_k \eqdef \Enc_k(\texttt{0}^m)$.

\paragraph{Query repetition}
\Enc\ in an IND-CPA-secure scheme should not always return the same ciphertext
for multiple encryptions of the same message.
This attack has advantage $1$ against any deterministic and stateless scheme:
\\~\\
\begin{tabular}{|l}
$c \leftarrow \mathcal{O}(\ang{0}, \ang{0})$\\
$c' \leftarrow \mathcal{O}(\ang{0}, \ang{1})$\\
Accept iff $c = c'$
\end{tabular}

\section{Block cipher modes}

\paragraph{Stateful counter mode (CTRS)}
Let $F$ be a PRF with $m = n$.
~\\[5pt]
\begin{tabular}{r|l}
\Gen & $k \leftarrow \bit^\ell$, $counter \leftarrow 0$ \\[5pt]
\Enc & echo $counter$ \\
     & for each message block $m$: \\
     & ~~~~echo $F_k(counter) \oplus m_i$ \\
     & ~~~~increment $counter$
\end{tabular}\\

CTRS is not used much, because preserving $counter$ is difficult.

\begin{thm}
If $F$ is a $(t,q,\eps)$-secure PRF, then
CTRS$(F)$ is $(t'\approx t, qn, 2\eps)$-IND-CPA secure.
\begin{proof}

We will show using a hybrid argument that
$\forall$ $(t',\sigma)$-bounded $\mathcal{A}'$ against CTRS$(F)$
where $\sigma \le n\,2^m$, there is a
$(t\approx t', q=\sigma/n)$-bounded attacker $\mathcal{A}$
attacking $F$ such that
$\text{Adv}_\text{CTRS$(F)$}^\text{indcpa}(\mathcal{A}')
\le 2\,\text{Adv}_F^\text{prf}(\mathcal{A})$.

Given $\mathcal{O}$ that is either $F$ or $U$:\\

$\mathcal{A} \eqdef \mathcal{A}_L \eqdef$
\begin{tabular}{|l}
$counter$ $\leftarrow$ $0$\\
$\mathcal{O}'(m,m') \eqdef$
\begin{tabular}{|l}
If $|m|=|m'|$, return $\bot$\\
Split $m$ into blocks $m_0, m_1, \ldots, m_{t-1}$\\
$y_i$ $\leftarrow$ $\mathcal{O}(counter + i)$ $\forall$ $i\in[0,t)$\\
Return $counter\Vert \text{join}_i(m_i \oplus y_i)$\\
$counter$ $\leftarrow$ $counter + t$
\end{tabular}\\
Accept iff $\mathcal{A}'^{\,\mathcal{O}'}$ accepts
\end{tabular}

Also define $\mathcal{A}_R$ similarly using $m'$ instead of $m$.

$\mathcal{A}_L^{F_k}$ perfectly simulates $L_k$ to $\mathcal{A}'$.

$\mathcal{A}_L^U$ does not simulate $R_k$, but it does simulate an oracle $\$$:
\\~\\
$\$(m,m') \eqdef$
\begin{tabular}{|l}
If $|m|=|m'|$, return $\bot$\\
Return $counter\Vert[\text{random bits}]$\\
$counter$ $\leftarrow$ $counter + \text{number of blocks}$
\end{tabular}

\begin{align*}
P_\ell &= \Pr_k[\mathcal{A}_L^{F_k}]= \Pr_k[\mathcal{A}'^{\,L_k}] \\
P_r &= \Pr_k[\mathcal{A}_R^{F_k}]= \Pr_k[\mathcal{A}'^{\,R_k}] \\
P_\$ &= \Pr_k[\mathcal{A}_L^U]=\Pr_k[\mathcal{A}_R^U]= \Pr_k[\mathcal{A}'^{\,\$}]
\end{align*}
\begin{align*}
\text{Adv}_\text{CTRS$(F)$}^\text{indcpa}(\mathcal{A}') &= |P_\ell - P_r| \\
&\le |(P_\ell - P_\$) + (P_r - P_\$)| & \text{(triangle inequality)} \\
&\le \eps+\eps = 2\eps
\end{align*}

\end{proof}
\end{thm}

\paragraph{Counter modes}~\\

\begin{tabular}{l|l|l}
CTRS & One global counter &
$\text{adv}^\text{indcpa} \le 2\,\text{adv}^\text{prf}$ \\[5pt]
CTR\$ & Random IV for each message &
$\text{adv}^\text{indcpa} \le 2\,\text{adv}^\text{prf}+q^2/2^n$ \\[5pt]
CTR\$\$ & Random IV for each block
\end{tabular}

\paragraph{Cipher block chaining (CBC)}

$C_0 = \text{IV}$,
$C_i = F_k(C_{i-1}\oplus m_i)$

\Dec\ requires being able to calculate $F^{-1}$.

If $F$ is a $(t,q,\eps)$-secure PRF, then
CBC[$F$] is $(\approx t, \sigma=qn, 2\eps+q^2/2^n)$-ind-cpa-secure.
The proof requires showing that for $U$, all inputs to $U$
are distinct (minus a birthday term).

\section{Message authentication code (MAC)}

Alice sends message $m$ and $t \leftarrow \Tag_k(m)$.
Eve intercepts $(m,t)$ and delivers $(m',t')$ to Bob.
Bob runs $\Ver_k(m',t')$.

$\Ver_k$ returns $\begin{cases}
m & \text{if $t'$ is a valid tag ($\Ver_k$ ``accepts'')} \\
\bot & \text{otherwise ($\Ver_k$ ``rejects'')}
\end{cases}$

Eve has access to a $\Tag_k$ oracle and can
make many attempts on $\Ver$.
Eve ``wins'' if \Ver\ accepts on an $m'$
not previously queried to $\Tag_k$.

\paragraph{Conerns ignored by this model}
\begin{itemize}
\item Dropped messages
\item Replay attacks (``freshness'' of messages)
\item Message sequence
\end{itemize}

\paragraph{Unforgeability under chosen message attack}

\[ \text{Adv}_\text{MAC}^\text{ufmca}(\mathcal{A}) \eqdef
\Pr_{k\leftarrow\Gen} \left[\;\mathcal{A}^{\Tag_k,\Ver_k}\;\text{``wins''}\;\right] \]

MAC is $(t, q_t, q_v, \eps)$-uf-cma-secure iff
advantage of an attacker
bounded by time $t$,
number of $\Tag$ queries $q_t$, and
number of $\Ver$ queries $q_v$
is less than $\eps$.

\paragraph{Examples of reasonable constants}
\begin{tabular}{r|l}
$t$ & $2^{80}$ or $2^{128}$ \\
$q_v,q_t$ & $2^{40}$ or $2^{56}$ \\
$\eps$ & $2^{-40}$ or $2^{-56}$
\end{tabular}

\paragraph{Brute-force MAC attacks}

\begin{itemize}
\item Key search:
Get a few oracle tags, and guess $k$.
$\text{Adv} = t/2^\ell$.
\item Tag search:
$\text{Adv} = t/2^s$ where $s$ is the tag length.
\end{itemize}

\paragraph{PRF-based MAC}
$\Tag_k \eqdef F_k$

$\forall$ $(t,q_t,q_v)$-bounded $\mathcal{B}$,
$\exists$ $(\approx t, q_t+q_v)$-bounded $\mathcal{A}$
such that \[ \text{Adv}_\text{PRFMAC[$F$]}^\text{ufcma}(\mathcal{B})
\le \text{Adv}_F^\text{prf}(\mathcal{A}) + q_v/2^n \;\text{.} \]

\paragraph{CBC-MAC}

For a fixed $t$, and $F:\bit^{nt}\rightarrow\bit^n$, CBC-MAC[$F$] is secure,
losing $(qt)^2/2^n$ advantage from that of $F$.

\paragraph{Cipher-based MAC (CMAC)}
Adds an extra step to the end of CBC-MAC
to make it secure for arbitrary-length messages.

Precompute $k_1$, $k_2$ $\in$ $\bit^n$ using $F_k(\texttt{0}^m)$.\\

$m'_t \leftarrow \begin{cases}
m'_t\oplus k_1 &: |m'_t|=n \\
m' \Vert \texttt{000}\ldots \oplus k_2 &: |m'_t|<n
\end{cases}$\\

Run $m_1 \Vert \ldots \Vert m_t$ through CBC-MAC.

\section{Combining authenticity and privacy}

\paragraph{Integrity of ciphertexts (INT-CTXT)}
$\Dec_k(c)$: returns decryption of $c$, or $\bot$ if $c$ is invalid.

$SE=(\Gen,\Enc,\Dec)$ is INT-CTXT secure iff $\forall$ bounded $\mathcal{A}$,
\[ \text{Adv}_{SE}^\text{int-ctxt}(\mathcal{A}) \eqdef
\Pr_{k\leftarrow\Gen} \left[\;\mathcal{A}^{\Enc_k,\Dec_k}\;\text{wins}\;\right]
< \eps \;\text{.} \]

UF-CMA-security does not necessarily give INT-CTXT security.
For example: If the output of $\Tag$ has a spurious bit that is
ignored by $\Ver$. So we require a stronger condition:

\paragraph{Strong unforgeability (SUF-CMA)}
Winning is redefined as: $\Ver_k$ accepts $(m',t')$
that was not previously a query/answer pair to $\Tag_k$.

\paragraph{Bad idea: Encrypt-and-tag}
$\AEnc \eqdef \EEnc_{k_e}(m) \Vert \Tag_{k_m}(m)$.
The tag could reveal information about $m$.

\paragraph{Bad idea: Tag-then-encrypt}
$\AEnc \eqdef \EEnc_{k_e}( m \Vert \Tag_{k_m}(m) )$.
The ciphertext might be forgeable (for example,
if $\EEnc$ appends a spurious bit).

\paragraph{Good idea: Encrypt-then-tag}
$\AEnc \eqdef \EEnc_{k_e}(m) \Vert \Tag_{k_m}(\EEnc_{k_e}(m))$.

\paragraph{Indistinguishability under chosen ciphertext attack (IND-CCA)}
IND-CPA $\wedge$ INT-CTXT $\Rightarrow$ IND-CCA.

\section{Hashing}

\paragraph{Hash function} $h:D\rightarrow \bit^n$, $D > 2^n$

\paragraph{Collision} $x,x' \in D : h(x)=h(x') \wedge x \neq x'$

\paragraph{Hash family} $H : \bit^\ell \times D \rightarrow \bit^n$

\paragraph{Collision resistance (CR)}
$H$ is $(t,\eps)$-collision resistant if
$\text{Adv}_H^\text{cr}(\mathcal{A}) \le \eps$
$\forall$ $t$-bounded $\mathcal{A}$.
\[ \text{Adv}_H^\text{cr}(\mathcal{A}) = \Pr_{k\leftarrow\bit^\ell}
\left[\;\mathcal{A}(k)\;\textrm{outputs a collision in}\;H_k\;\right] \]

\paragraph{Real-world hash functions}
\begin{tabular}{lrl}
MD4 & $n=128$ & Broken \\
MD5 & $n=128$ & Broken \\
SHA-1 & $n=160$ & Maybe broken \\
SHA-256 & $n=256$ & Good \\
SHA-3 & & Good
\end{tabular}

Hash output lengths need to be longer than encryption key lengths
because brute-force attacks can test $\approx q^2$ pairs in $q$ hashes
(``birthday attack'').

\paragraph{Second preimage resistance / target collision resistance (TCR)}
Given $x$, attacker must find $x'$ such that $x,x'$ is a collision.
\[ \text{Adv}_H^\text{tcr}(\mathcal{A}) =
\Pr_{\substack{k\leftarrow\bit^\ell,\\x\leftarrow D}}
\left[\;\mathcal{A}(k, x)\;\text{outputs a collision}\;\right] \]
where $D$ is some distribution over the message space.

Brute force attack does not have a birthday advantage in this game.

CR $\Rightarrow$ TCR.

\paragraph{One-wayness (OW)}

\[ \text{Adv}_H^\text{ow}(\mathcal{A}) =
\Pr_{\substack{k\leftarrow\bit^\ell,\\x\leftarrow D}}
\left[\;\mathcal{A}(k, H_k(x))\;\text{outputs}\;x':H_k(x')=H_k(x)\;\right] \]

TCR $\Rightarrow$ OW for ``high-entropy'' $D$
(so that $H_k(x)$ reveals very little about $x$).

\paragraph{Merkle-Damg{\aa}rd (MD) transform}
$\text{MD}[h]_k(M\in\bit^*)$

Uses a compression function $h_k:\bit^\ell\times\bit^{b+n}\rightarrow\bit^n$

Break $M$ into $M_1,\ldots,M_t$ s.t. $\|M_i\|=b$

\begin{align*}
y_1 &\leftarrow h_k(\;M_1\,\Vert\,\ang{0}\;) \\
y_2 &\leftarrow h_k(\;M_2\,\Vert\,y_1\;) \\
&\vdots\\
y_i &\leftarrow h_k(\;M_i\,\Vert\,y_{i-1}\;) \\
&\vdots\\
y_t &\leftarrow h_k(\;M_t\,\Vert\,y_{t-1}\;) \\
y &\leftarrow h_k(\;\ang{t}\,\Vert\,y_t\;)
\end{align*}

\paragraph{If $h$ is CR, then MD[h] is CR}
Let $\mathcal{B}$ attack MD$[h]$ in CR game.
We can build $\mathcal{A}$ attacking $h$ in CR game.
$\mathcal{A}(k\in\bit^\ell)$ will use a collision
$x,x'$ in MD$[h_k]$ to find a collision in $h_k$.

If $x,x'$ have different numbers of blocks:
Then $\ang{t}\,\Vert\,M_t, \ang{t'}\,\Vert\,M'_t$ is a collision in $h_k$.

Otherwise: Walk backward through the MD process to find a step
where $M_i\,\Vert\,y_{i-1} \neq M'_i\,\Vert\,y'_{i-1}$.

\paragraph{HMAC} Secure MAC based on hash function.

$\text{HMAC}_k(m) = H(
  (k \oplus \text{opad})
  \,\Vert\,
  H(
    (k \oplus \text{ipad})
    \,\Vert\,
    m
  )
)$
where $k$ is the MAC key padded to the length of the compression function,
ipad and opad are fixed strings of the same length.

Only TCR security of $H$ is required for the security of HMAC.

\end{document}
